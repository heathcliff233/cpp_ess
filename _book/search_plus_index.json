{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction crash course before programming test language: C++ enjoy! By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 13:11:30 "},"01summary.html":{"url":"01summary.html","title":"01. Summary","keywords":"","body":"概述 十进制与二进制转化（小数） 二进制转十进制 第 i 位 *2^(-i) 十进制转二进制 *2 取整数位，直到乘积为整数 二进制与十六进制转化 每4位一转化 标识符 由大小写英文字母、数字以及下划线所构成的字符序列，第一个字符不能是数字 By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 13:38:19 "},"02data.html":{"url":"02data.html","title":"02. Data","keywords":"","body":"数据类型与表达式 各类型所占空间 int占2或4个字节 int型用补码表示 float占4个字节 double占8个字节 逻辑值可以参加算术运算 true对应1，false对应0 sizeof() 计算数据类型所占内存大小 给已有数据类型取别名 typedef 字符常量与字符串常量区别 字符常量用‘’，字符串常量用“”。 对字符常量操作按char类型进行，对字符串常量操作按字符数组 字符常量在内存中占一个字节，字符串常量占len(字符个数)+1(\\0)字节 实数比较运算 x == y (X) -> fabs(x-y) x != y (X) -> fabs(x-y) > 1e-6 短路求值 对于&&，||，若第一个操作数已经能确定整体的值，则不再计算后面的 guard (num != 0)&&(1/num > 0) By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 19:39:06 "},"03expression.html":{"url":"03expression.html","title":"03. Expression","keywords":"","body":"语句 屁都没有 By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 16:00:57 "},"04function.html":{"url":"04function.html","title":"04. Function","keywords":"","body":"函数 局部变量与全局变量 int m = 0; //global int main() { int a = 0 ; //local a++ ; //OK while(a 文件作用域 在全局标识符的定义中加上static修饰符，则该全局标识符就成了具有文件作用域的标识符，只能在定义他们的源文件(模块)中使用 //file1.cpp static int y; //文件作用域 static void f(){} //文件作用域 //file2.cpp extern int y; extern void f(); void g(){ ...y... //Error f(); //Error } static两重含义 局部变量定义中，static修饰符用于指定局部变量采用静态储存分配 在全局标识符定义中，static修饰符用于把全局标识符的作用域改编为文件作用域 变量生存期 静态：从程序开始执行时分配内存，程序结束时收回。全局变量具有静态生存期。 自动：执行到定义时分配，复合语句执行结束就被收回。局部变量和函数的参数有自动生存期。 动态：内存空间在程序中显式地用new或malloc库函数分配、用delete操作或free库函数收回。动态变量具有动态生存期。 储存类修饰符 定义局部变量时加上储存类修饰符显式指出它们的生存期 auto：为局部变量默认储存类，具有自动生存期 static：使其具有静态生存期，只在第一次调用时初始化 register：同样自动生存期，根据CPU寄存器的使用情况决定是否放在寄存器中 递归函数 直接递归 void s(){ s(); } 间接递归 extern void g(); void f(){ ......; ...g()...; } void g(){ ......; ...f()...; } By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 18:42:16 "},"05type.html":{"url":"05type.html","title":"05. Type","keywords":"","body":"构造数据类型 枚举类型 enum Day {SUN,MON,TUE,WED,THU,FRI,SAT} 默认第一个对应0，依次加1 指定时 enum Day {SUN=7,MON=1,TUE,WED,THU,FRI,SAT} 定义时 Day d1; d1 = 1; //Error SUN > MON; //true 算术运算 Day d; cin >> d; //Error d = d+1; //Error d = (Day)(d+1); //OK cout 通过输入赋值 (可以把一个枚举值赋值给一个整型变量，但不能把整型赋值给枚举型) #include using namespace std; int main(){ Day d; int i; cin >> i; switch(i) { case 0: d = SUN; break; case 1: d = MON; break; case 2: d = TUE; break; case 3: d = WED; break; case 4: d = THU; break; case 5: d = FRI; break; case 6: d = SAT; break; default: cout 向函数传递一维数组 #include using namespace std; int max(int x[] , int num){ int j=0; for(i=1 ; i x[j]){ j = i; } } return j; } int main(){ int a[10],index_max; index_max = max(a,10); cout 一维字符数组 char s[10]; //表示长度为9的字符串 初始化 char s[10] = {'h','e','l','l','o','\\0'}; char s[10] = {\"hello\"}; char s[10] = \"hello\"; char s[] = \"hello\"; 二维数组 例子 #include using namespace std; int main(){ const int N=3; int a[N][N]; int i,j; for(i=0 ; i> a[i][j]; } } for(i=0 ; i 初始化 int a[2][3] = {{1,2,3},{4,5,6}}; int a[2][3] = {1,2,3,4,5}; int a[2][3] = {{1,2},{3,4}} int a[][3] = {{1,2,3},{4,5,6},{7,8,9}} By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 22:20:59 "},"06node.html":{"url":"06node.html","title":"06. Node","keywords":"","body":"Node 指针 指针赋值 int x,*p,*p1; double y,*q; p = &x; //OK q = &y; //OK p = &y; //Error p1 = p; //PK p = 0; //OK,p不指向任何变量 p = 120; //Error, 120为int型 p = (*int)120; //OK 指针类型常量 int x,y; int *const p = &x; //p必须初始化 *p = 1; //OK p = &y; int x,y; const int *const p = &x; *p = 1; //Error p = &y; //Error 动态变量 int *p; p = new int[n]; //p指向新创建的int型动态变量 delete []p; int x,*p; p = &x; delete p; //Error 链表 struct Node{ int content; Node *next; } Node *head = NULL; Node *p = new Node; p -> content = a; p -> next = NULL; head -> next = p; 插入在i Node *q = head; int j=1; while(jnext == NULL){ break; } q = q->next; j++; } if(j == i){ p->next = q->next; q->next = p; } 引用类型 int x; int &y = x; //必须初始化 By heathcliff233，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-24 22:20:57 "}}